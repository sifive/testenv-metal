/* SPDX-License-Identifier: Apache-2.0 */

#ifndef __INTERRUPT_HANDLERS_H
#define __INTERRUPT_HANDLERS_H

#include <metal/cpu.h>
#include <metal/interrupt.h>
#include <metal/riscv.h>

{% if harts|length > 1 and 'mmu_type' in harts[1] %}
#define __METAL_NUM_EXCEPTIONS 16
{% elif 'mmu_type' in harts[0] %}
#define __METAL_NUM_EXCEPTIONS 16
{% else %}
#define __METAL_NUM_EXCEPTIONS 12
{% endif %}

{% if local_interrupts is defined %}
#define __METAL_NUM_LOCAL_INTERRUPTS {{ local_interrupts.irqs|length }}
{% else %}
#define __METAL_NUM_LOCAL_INTERRUPTS 16
{% endif %}

{% if global_interrupts is defined %}
#define __METAL_NUM_GLOBAL_INTERRUPTS {{ global_interrupts.irqs|length }}
{% else %}
#define __METAL_NUM_GLOBAL_INTERRUPTS 0
{% endif %}

/*!
 * @brief Function signature for interrupt callback handlers
 */
typedef void (*metal_interrupt_handler_t)(void);

/*!
 * @brief Function signature for exception handlers
 */
typedef void (*metal_exception_handler_t)(struct metal_cpu cpu, int ecode);


extern const metal_exception_handler_t __metal_exception_table[__METAL_NUM_EXCEPTIONS];
extern const metal_interrupt_handler_t __metal_local_interrupt_table[__METAL_NUM_LOCAL_INTERRUPTS];

void __metal_exception_handler(riscv_xlen_t mcause);

void metal_exception_instruction_address_misaligned_handler(struct metal_cpu cpu, int ecode);
void metal_exception_instruction_address_fault_handler(struct metal_cpu cpu, int ecode);
void metal_exception_illegal_instruction_handler(struct metal_cpu cpu, int ecode);
void metal_exception_breakpoint_handler(struct metal_cpu cpu, int ecode);
void metal_exception_load_address_misaligned_handler(struct metal_cpu cpu, int ecode);
void metal_exception_load_access_fault_handler(struct metal_cpu cpu, int ecode);
void metal_exception_store_amo_address_misaligned_handler(struct metal_cpu cpu, int ecode);
void metal_exception_store_amo_access_fault_handler(struct metal_cpu cpu, int ecode);
void metal_exception_ecall_from_u_mode_handler(struct metal_cpu cpu, int ecode);
void metal_exception_ecall_from_s_mode_handler(struct metal_cpu cpu, int ecode);
void metal_exception_default_handler(struct metal_cpu cpu, int ecode);
void metal_exception_ecall_from_m_mode_handler(struct metal_cpu cpu, int ecode);
void metal_exception_instruction_page_fault_handler(struct metal_cpu cpu, int ecode);
void metal_exception_load_page_fault_handler(struct metal_cpu cpu, int ecode);
void metal_exception_store_amo_page_fault_handler(struct metal_cpu cpu, int ecode);


void metal_riscv_cpu_intc_default_handler(void) __attribute__((interrupt));

void metal_riscv_cpu_intc_usip_handler(void){% if local_interrupts['irqs'][0]['hwvectored'] %} __attribute__((interrupt)){% endif %};
void metal_riscv_cpu_intc_ssip_handler(void){% if local_interrupts['irqs'][1]['hwvectored'] %} __attribute__((interrupt)){% endif %};
void metal_riscv_cpu_intc_msip_handler(void){% if local_interrupts['irqs'][3]['hwvectored'] %} __attribute__((interrupt)){% endif %};

void metal_riscv_cpu_intc_utip_handler(void){% if local_interrupts['irqs'][4]['hwvectored'] %} __attribute__((interrupt)){% endif %};
void metal_riscv_cpu_intc_stip_handler(void){% if local_interrupts['irqs'][5]['hwvectored'] %} __attribute__((interrupt)){% endif %};
void metal_riscv_cpu_intc_mtip_handler(void){% if local_interrupts['irqs'][7]['hwvectored'] %} __attribute__((interrupt)){% endif %};

void metal_riscv_cpu_intc_ueip_handler(void){% if local_interrupts['irqs'][8]['hwvectored'] %} __attribute__((interrupt)){% endif %};
void metal_riscv_cpu_intc_seip_handler(void){% if local_interrupts['irqs'][9]['hwvectored'] %} __attribute__((interrupt)){% endif %};
{% if global_interrupts is defined %}
void metal_riscv_plic0_source_0_handler(void){% if local_interrupts['irqs'][11]['hwvectored'] %} __attribute__((interrupt)){% endif %};
{% else %}
void metal_riscv_cpu_intc_meip_handler(void){% if local_interrupts['irqs'][11]['hwvectored'] %} __attribute__((interrupt)){% endif %};
{% endif %}

{% if 'sifive,clic0' in devices %}
void metal_sifive_clic0_csip_handler(void){% if local_interrupts['irqs'][12]['hwvectored'] %} __attribute__((interrupt)){% endif %};
{% endif %}

{% if 'sifive,buserror0' in devices %}
  {% if local_interrupts['irqs']|length >= 128 %}
void metal_sifive_buserror0_source_0_handler(void){% if local_interrupts['irqs'][128]['hwvectored'] %} __attribute__((interrupt)){% endif %};
  {% endif %}
{% endif %}

{% if local_interrupts is defined %}
    {% for irq in local_interrupts.irqs|unique_irqs %}
       {% if irq.id >= 16 and irq.source.compatible != None %}
void metal_{{ to_snakecase(irq.source.compatible) }}_source_{{ irq.source.id }}_handler(void){% if local_interrupts['irqs'][irq.id]['hwvectored'] %} __attribute__((interrupt)){% endif %};
        {% endif %}
    {% endfor %}
{% endif %}

{% if global_interrupts is defined %}
    {% for irq in global_interrupts.irqs|unique_irqs %}
       {% if irq.source.compatible != None %}
void metal_{{ to_snakecase(irq.source.compatible) }}_source_{{ irq.source.id }}_handler(void);
        {% endif %}
    {% endfor %}
{% endif %}

#endif 
